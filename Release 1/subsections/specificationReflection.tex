\subsection{Quality Requirements}

\subsubsection{Importance of Quality Requirements}
We noticed early on that quality requirements are just as important as functional requirements. As many know functional requirements exist to explain what the system does while quality explain how well the task should be done. By creating a quality grid we established which quality attributes are crucial for our project, these involve performance, usability, reliability and security. 

\subsubsection{Experiences and Insights}
At the beginning of our project we understood quickly how important proper quality requirements are for our key differentiators. For example, the HeatmapSearch feature is one of our key differentiator, however this feature depends entirely on its performance and usability. From this enlightenment we had to reconsider our functional and quality requirements and reconstruct them which is reflected on further down. 

Another insight we had was the gap existing between user expectations and technical implementation on features. Such as when we defined quality requirement using usability score (SUS) we learned to think outside the core product and how users would see and use the product.  


\subsubsection{Challenges}
One major challenge was figuring out what level of detail we should use for the specific quality requirement. For example, at the start some of our requirements where to vaguely defined where there could be misinterpretation. We had some requirements at the start saying "system should show results fast" which is not well defined where different users reads the term fast as different values. We then changed these requirements to have more of a value such as "search results should be displayed within 2 seconds" which can be seen in the quality requirement FastSearchResults.

Another challenged was how we should prioritize our requirements since there is no project who has unlimited resources to make all quality aspects critical. Hence as mentioned before we created a quality grid where we discuss and prioritize what we deemed critical for our project.


\subsubsection{What We Would Do Differently}
For future projects we would recommend to:
\begin{itemize}
    \item Involve stakeholders earlier, this would help create testable requirements and minimize the risk of creating requirements that is not needed for the different stakeholders. Such as saying a results should appear in 0.1 ms or 1 ms has no major impact on the user but it would be a major cost for the team to develop.
    \item Create a clear connection between quality requirements and features earlier on to improve aspects such as traceability and improve the workflow and understanding from developers.
    \item Create a quality checklist earlier on to help with validation and testing.
\end{itemize}

\subsubsection{Final Reflection}
In conclusion we learned that quality requirements its not something that is optional for projects but its essential factor that is needed for success of a product. By having the quality requirements well defined and constructed it creates a way to check if its competitive on the market or if it fulfills users needs and wants.



\subsection{Data Requirements}

For the data requirements three methods were chosen. These methods were data model, data dictionary and virtual window. For this project one experience was that
making data requirements are more or less difficult depending on what part of the project is developed. The data requirements used were thus targeting the user
account system in the product as well as the search system for the flights. These are the crucial parts that are the most important to include in early releases.
Other areas such as the ad providers or how the data from airlines should be handled are harder to construct and a reason for this is a lack of knowledge in
how this data would be represented from these sources, this would be improved over the release iterations in the project over time.

Another point that was explored was in which level the E/R-model was placed. Initially it was placed in the design level but since data requiremtns usually are similar
across the different levels it was chosen to be moved up to domain level instead in order to not interfere with the design level implementations.
