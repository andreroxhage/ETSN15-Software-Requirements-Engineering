\subsection{Restructured requirements specification}
During the development of our requirements specification, we initially structured the document by categorizing requirements into distinct sections such as functional, quality, and data requirements. While this approach provided a clear separation of requirement types as we learned about them in the course, we encountered difficulties in effectively contextualizing them within specific features and functionalities of the system.

To address this, we restructured our requirements specification into sections based on key system areas, such as the heatmap, security, and search functionalities. This new structure allows all relevant requirements, regardless of type, to be included within the appropriate section, making it easier to see how different levels of requirements interact within a particular feature. By organizing the document this way, we have improved traceability, making it more intuitive to understand how individual requirements contribute to the overall system design and objectives. Additionally, this restructuring has resulted in fewer cross-references, simplifying navigation and reducing the complexity of managing related requirements.

Also, we updated our requirement naming convention from numbered identifiers to camelCase IDs. This change enhances clarity and consistency across the document while improving readability and maintainability. The camelCase format ensures that requirement identifiers are more descriptive and making cross-referencing simpler when working with different system components.

These refinements have significantly enhanced the structure and readability of our requirements specification, ensuring that it better supports both development and validation processes.

\subsection{Release planning and prioritization}

We used three different methods for prioritazation, benefits cost analysis, priority classification and prioritazation though constraint-based release Planning in RecT. These methods were combined in order to create a interative release plan that maximised value while costing as little as possible. To use only one of these would make the release planning more susceptible to inconsistencys. This is why it was important for us to make the techniques independent from each other.

One of the main difficulties was balancing the needs of different stakeholders while also managing dependencies between features. Many subjective estimations can be harmful for the result since the prioritaztion is not made in a systematic way. Manually handling these dependencies proved too complex which is why  we decided to use the tool RecT to automate the process. The score of the relases and features that RecT gave us were somewhat ambiguous since fictitious estimates were used in benefit and cost. This made the result an abstract number which actually was negative sometimes. Even though this part of the result was not desirable, the tool provided a useful relative comparison between features. The release plan RecT generated, with realeses R4, R5 and R6, seemed realistic given our features and constraints. Looking back, we would have benefited from using RecT earlier in the project. This would have given us more time to refine our dependencies and prioritize features more effectively. 

Benefits cost analysis was chosen because it provides a quantifiable way to compare features based on benefit and cost. This was a good way further analysize our stakeholders, noticing how their needs can differ and sometimes contradict each other. While travels value usability, the travel agency might prioritize safely for example. A scale of only three options, “Must-Have”, “Important” \& “Nice to have”, was chosen to was chosen to avoid unnesesary complexity and ensure a clear prioritization.

Constraint based priorizitaion seemed like a logical way to make the solution space smaller which would lead us closer to a more realistic release plan. After manually connecting different types of dependencies, “Precedence”, ”Coupling” \& ”Excludes”, to features, we discussed how the types of dependencies varied from each other and when each should be applied. By discussing this our understanding out our insight on how the features relate to each other got more clear. We also discussed how the complexity would be much larger in a real world scenario as every dependency would be more important to specify. 
